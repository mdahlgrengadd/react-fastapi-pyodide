interface GenerateOptions {
  schemaUrl: string;
  outputDir: string;
  apiBaseUrl?: string;
}

interface OpenAPIParameter {
  name: string;
  in: string;
  required?: boolean;
  schema?: OpenAPISchemaObject;
}

interface OpenAPISchemaObject {
  type?: string;
  format?: string;
  enum?: string[];
  items?: OpenAPISchemaObject;
  properties?: Record<string, OpenAPISchemaObject>;
  required?: string[];
  $ref?: string;
}

interface OpenAPIEndpoint {
  operationId?: string;
  summary?: string;
  description?: string;
  parameters?: OpenAPIParameter[];
  requestBody?: {
    content?: Record<string, { schema?: OpenAPISchemaObject }>;
  };
  responses?: Record<
    string,
    {
      description?: string;
      content?: Record<string, { schema?: OpenAPISchemaObject }>;
    }
  >;
}

interface OpenAPIPath {
  [method: string]: OpenAPIEndpoint;
}

interface OpenAPISchema {
  paths?: Record<string, OpenAPIPath>;
  components?: {
    schemas?: Record<string, OpenAPISchemaObject>;
  };
}

export const generateTypes = async (
  options: GenerateOptions
): Promise<string> => {
  try {
    console.log("ðŸš€ Generating types from FastAPI schema...");

    // Fetch OpenAPI schema
    const response = await fetch(options.schemaUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch schema: ${response.statusText}`);
    }

    const schema: OpenAPISchema = await response.json();

    // Generate TypeScript types
    const typescript = generateTypeScript(schema);

    console.log("âœ… Generated TypeScript types successfully");
    return typescript;
  } catch (error) {
    console.error("âŒ Failed to generate types:", error);
    throw error;
  }
};

export const generateHooks = (schema: OpenAPISchema): string => {
  let hooks = `// Generated React hooks from FastAPI OpenAPI schema
// Do not edit this file manually

import { useAPIQuery, useAPIMutation, usePaginatedQuery } from 'react-router-fastapi';
import type * as Types from './api';

`;
  if (schema.paths) {
    for (const [path, methods] of Object.entries(schema.paths)) {
      for (const [method, endpoint] of Object.entries(methods)) {
        if (endpoint && endpoint.operationId) {
          hooks += generateHookForEndpoint(endpoint.operationId, method, path);
        }
      }
    }
  }

  return hooks;
};

function generateTypeScript(schema: OpenAPISchema): string {
  let typescript = `// Generated TypeScript types from FastAPI OpenAPI schema
// Do not edit this file manually

`;

  // Generate interfaces from schema components
  if (schema.components?.schemas) {
    for (const [name, schemaObj] of Object.entries(schema.components.schemas)) {
      typescript += generateInterface(name, schemaObj);
    }
  }

  // Generate API endpoints interface
  typescript += `
// API Endpoints
export interface APIEndpoints {
`;

  if (schema.paths) {
    for (const [path, methods] of Object.entries(schema.paths)) {
      for (const [method, endpoint] of Object.entries(methods)) {
        if (endpoint && endpoint.operationId) {
          typescript += `  ${endpoint.operationId}: {
    path: '${path}';
    method: '${method.toUpperCase()}';
    summary?: '${endpoint.summary || ""}';
  };
`;
        }
      }
    }
  }

  typescript += `}

export default {};
`;

  return typescript;
}

function generateInterface(name: string, schema: OpenAPISchemaObject): string {
  let interfaceStr = `export interface ${name} {
`;

  if (schema.properties) {
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const optional = !schema.required?.includes(propName) ? "?" : "";
      const type = getTypeScriptType(propSchema);
      interfaceStr += `  ${propName}${optional}: ${type};
`;
    }
  }

  interfaceStr += `}

`;
  return interfaceStr;
}

function getTypeScriptType(schema: OpenAPISchemaObject): string {
  if (schema.type === "string") {
    if (schema.enum) {
      return schema.enum.map((val: string) => `'${val}'`).join(" | ");
    }
    return "string";
  } else if (schema.type === "number" || schema.type === "integer") {
    return "number";
  } else if (schema.type === "boolean") {
    return "boolean";
  } else if (schema.type === "array") {
    const itemType = schema.items ? getTypeScriptType(schema.items) : "unknown";
    return `${itemType}[]`;
  } else if (schema.type === "object") {
    return "Record<string, unknown>";
  } else if (schema.$ref) {
    return schema.$ref.split("/").pop() || "unknown";
  }
  return "unknown";
}

function generateHookForEndpoint(
  operationId: string,
  method: string,
  path: string
): string {
  const hookName = `use${
    operationId.charAt(0).toUpperCase() + operationId.slice(1)
  }`;

  if (method === "get") {
    const hasPathParams = path.includes("{");
    if (hasPathParams) {
      return `export const ${hookName} = (pathParams: Record<string, string>, queryParams?: Record<string, unknown>) =>
  useAPIQuery(['${operationId}', pathParams], \`${path.replace(
        /\{([^}]+)\}/g,
        "${pathParams.$1}"
      )}\`, { params: queryParams });

`;
    } else {
      return `export const ${hookName} = (params?: Record<string, unknown>) =>
  useAPIQuery('${operationId}', '${path}', { params });

`;
    }
  } else {
    return `export const ${hookName} = () =>
  useAPIMutation('${path}', '${method}');

`;
  }
}
